#+TITLE: Cell Profiler measurements

Do you need to use [[https://github.com/CellProfiler][CellProfiler]] features, but you want to do it in a programmatic way? Look no more, this package was developed by and for the click-a-phobic scientists.

* Quick overview
** Installation
#+begin_src bash
pip install cp-measure
#+end_src

** Usage
Commonly users want to calculate all the features. This shows the simplest way to do it.
#+begin_src python
import numpy as np

from cp_measure.bulk import get_all_measurements

measurements = get_all_measurements()
print(measurements.keys())
# dict_keys(['radial_distribution', 'radial_zernikes', 'intensity', 'sizeshape', 'zernike', 'ferret', 'granularity', 'texture'])

size = 200
rng = numpy.random.default_rng(42)
pixels = rng.integers(low=0, high=10, size=(size, size))

mask = np.zeros_like(pixels, dtype=bool)
mask[5:-6, 5:-6] = True

results = {}
for name, v in get_all_measurements().items():
    results = {**results, **v(mask, pixels)}

print(measurements)

# Skipped some lines to avoid repetition
# {
# 'RadialDistribution_ZernikeMagnitude_4_0': 0.3135676575501373,
# 'RadialDistribution_ZernikePhase_4_0': -1.5707963267948966,
# ...
# 'RadialDistribution_ZernikeMagnitude_9_9': 0.0025004179581405678,
# 'RadialDistribution_ZernikePhase_9_9': -2.8100218596190443,
# 'Intensity_IntegratedIntensity': 160425.0,
# 'Intensity_MeanIntensity': 4.491055681531872,
# 'Intensity_StdIntensity': 2.869878495344839,
# 'Intensity_MinIntensity': 0.0,
# 'Intensity_MaxIntensity': 9.0,
# 'Intensity_IntegratedIntensityEdge': 3253.0,
# 'Intensity_MeanIntensityEdge': 4.325797872340425,
# 'Intensity_StdIntensityEdge': 2.8725543532431024,
# 'Intensity_MinIntensityEdge': 0.0,
# 'Intensity_MaxIntensityEdge': 9.0,
# 'Intensity_MassDisplacement': 0.3611233465245226,
# 'Intensity_LowerQuartileIntensity': 2.0,
# 'Intensity_MedianIntensity': 4.0,
# 'Intensity_MADIntensity': 2.0,
# 'Intensity_UpperQuartileIntensity': 7.0,
# 'Location_CenterMassIntensity_X': 98.79390369331463,
# 'Location_CenterMassIntensity_Y': 99.29653732273648,
# 'Location_CenterMassIntensity_Z': 0.0,
# 'Location_MaxIntensity_X': 5.0,
# 'Location_MaxIntensity_Y': 5.0,
# 'Location_MaxIntensity_Z': 0.0,
# 'SpatialMoment_0_0': 35721.0,
# ...
# 'SpatialMoment_2_3': 704675332061064.0,
# 'CentralMoment_0_0': 35721.0,
# 'CentralMoment_0_1': 0.0,
# ...
# 'CentralMoment_2_3': 0.0,
# 'NormalizedMoment_0_0': nan,
# 'NormalizedMoment_0_1': nan,
# 'NormalizedMoment_0_2': 0.08333100043858421,
# ...
# 'NormalizedMoment_3_3': 0.0,
# 'HuMoment_0': 0.16666200087716843,
# ...
# 'HuMoment_6': 0.0,
# 'InertiaTensor_0_0': 2976.6666666666665,
# 'InertiaTensor_0_1': -0.0,
# 'InertiaTensor_1_0': -0.0,
# 'InertiaTensor_1_1': 2976.6666666666665,
# 'InertiaTensorEigenvalues_0': 2976.6666666666665,
# 'InertiaTensorEigenvalues_1': 2976.6666666666665,
# 'Zernike_0_0': 0.6433382868281151,
# ...
# 'Zernike_9_9': 3.9043711966673347e-19,
# 'MinFeretDiameter': 188.0,
# 'MaxFeretDiameter': 265.87214972614186,
# 'Granularity_1': 24.19935948759008,
# ...
# 'Granularity_16': 0.0,
# 'AngularSecondMoment_3_00_256': 0.012370162781177797,
# ...
# 'AngularSecondMoment_3_12_256': 0.047711060488654665,
# 'Contrast_3_00_256': 0.012376329691736127,
# ...
# 'Contrast_3_12_256': 0.05146775986581612,
# 'Correlation_3_00_256': 0.01237206590950822,
# ...
# 'Correlation_3_12_256': 0.0488404814927021,
# 'Variance_3_00_256': 0.01236480273597283,
# ...
# 'Variance_3_12_256': 0.03896703820222742}
#+end_src

*** Call specific measurements
If you need a specific measurement/feature you can just import it. Note that measurements come in sets, so you have to fetch the one that you specifically require from the resultant dictionary. Any available measurement can be found using code as follows:
#+begin_src python
  import numpy as np

  from cp_measure.minimal.measureobjectsizeshape import get_sizeshape
  #       "radial_distribution": measureobjectintensitydistribution.get_radial_distribution,
  #       "radial_zernikes": measureobjectintensitydistribution.get_radial_zernikes,
  #       "intensity": measureobjectintensity.get_intensity,
  #       "zernike": measureobjectsizeshape.get_zernike,
  #       "ferret": measureobjectsizeshape.get_ferret,
  #       "granularity": measuregranularity.get_granularity,
  #       "texture": measuretexture.get_texture,
  
  mask = np.zeros((50, 50), dtype=bool)
  mask[5:-6, 5:-6] = True
  get_sizeshape(mask, None) # pixels, the second argument, is not necessary for this measurement
#+end_src

* Pending measurements 
You can follow progress [[https://docs.google.com/spreadsheets/d/1_7jQ8EjPwOr2MUnO5Tw56iu4Y0udAzCJEny-LQMgRGE/edit?usp=sharing][here]]. The Image-wide functions will not be implemented directly, as they were originally implemented as additional functions to the Object (mask) functions. We will adjust the existing functions assume that an image-wide measurement is the same as measuring an object with the same size as the intensity image.

* Additional notes
- This is a temporary library. The final goal is to integrate this on 'cellprofiler-library', containing all the functional components of CellProfilers isolated from the user interface to facilitate automation.
- This is not optimised for efficiency (yet). We aim to reproduce the 'vanilla' results of CellProfiler with minimal code changes. Optimisations will be implemented once we come up with a standard interface for functionally-focused CellProfiler components.
- The functions exposed perform minimal checks. They will fail if provided with empty masks. Not all functions will fail if provided with masks only.
